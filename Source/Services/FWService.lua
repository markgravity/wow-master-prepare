---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by markg.
--- DateTime: 19/06/2021 17:42
---

local ContainerItemInfo = MasterCore.ContainerItemInfo
local UNIT = MasterCore.UNIT
local Config = MasterPrepare.Config
local VENDOR_FOODS = MasterPrepare.VENDOR_FOODS
local VENDOR_WATERS = MasterPrepare.VENDOR_WATERS
local CONJURE_FOODS = MasterPrepare.CONJURE_FOODS
local CONJURE_WATERS = MasterPrepare.CONJURE_WATERS
local FW_TYPE = MasterPrepare.FW_TYPE
local ItemInfo = MasterCore.ItemInfo
local PREFER_CONJURE_TYPE = MasterPrepare.PREFER_CONJURE_TYPE

local FWService, super = MasterCore.Class:Create("FWService")
MasterPrepare.FWService = FWService

function FWService:Init(type)
    self = super.Init(self)
    self.type = type
    self.suitableItems = { }
    self.numberNeeded = 0
    return self
end

function FWService:Check()
    local config = self:_GetConfig().buy

    local suitableItems = self:_FindMostSuitableItems()
    self.junkItems, self.suitableItems = self:_GetJunks(suitableItems)
    local numberNeeded, current = self:_GetNumberNeeded(self.suitableItems)
    self.numberNeeded = numberNeeded

    return current >= config:GetMinRestock(), self.suitableItems, self.numberNeeded
end

function FWService:_GetJunks(suitableItems)
    local config = self:_GetConfig().sell
    local items = self:_GetItems()
    local junkItems = {}

    -- Get lower level
    local lowerLevel
    for _, item in pairs(suitableItems) do
        lowerLevel = item.minLevel - 1
        break
    end

    if config:GetEnable() then
        -- Get all items which lower level than base level
        local lowerItems = {}
        if config:GetCriteriaLowValue() then
            for _, item in ipairs(items) do
                if item.minLevel <= lowerLevel then
                    lowerItems[item.id] = true
                else
                    break
                end
            end
        end

        -- Append suitable items which not available in opened vendor
        local unavailableSuitableItems = {}
        if config:GetCriteriaLowStack() then

            -- Get merchant items
            local merchantItems = {}
            for i = 1, GetMerchantNumItems() do
                local itemLink = GetMerchantItemLink(i)
                local itemID = GetItemID(itemLink)

                if itemID then
                    merchantItems[itemID] = true
                end
            end

            local found = false
            for itemID, _ in pairs(suitableItems) do
                if not merchantItems[itemID] then
                    unavailableSuitableItems[itemID] = true
                else
                    found = true
                end
            end

            -- Reset if the current vendor doesn't provide any item in suitableItems
            if not found then
                unavailableSuitableItems = {}
            end
        end

        -- Only add if they are available in bags
        for bag = 0, NUM_BAG_SLOTS do
            local numSlots = GetContainerNumSlots(bag)
            if numSlots > 0 then
                for slot = 1, numSlots do
                    local itemID = GetContainerItemID(bag, slot)

                    if lowerItems[itemID] then
                        junkItems[itemID] = true
                    end

                    if unavailableSuitableItems[itemID] then
                        local containerItemInfo = ContainerItemInfo:Init(bag, slot)
                        local item = ItemInfo:Init(itemID)

                        if item and containerItemInfo.itemCount < item.stackCount then
                            junkItems[itemID] = true
                            suitableItems[itemID] = nil
                        end
                    end
                end
            end
        end
    end

    return junkItems, suitableItems
end

function FWService:_FindMostSuitableItems()
    local baseSuitableItem
    local playerLevel = UnitLevel(UNIT.PLAYER)
    local suitableItems = {}
    local config = self:_GetConfig()
    local items = self:_GetItems()
    local playerStat = self:_GetPlayerStat()

    for i = 1, #items do
        local item = items[#items + 1 - i]

        -- Add items at the same tier
        if baseSuitableItem ~= nil then
            -- No more item at the same tier
            if item.effectValue ~= baseSuitableItem.effectValue then
                break
            end
            suitableItems[item.id] = item
        else
            -- Find a suitable item
            repeat
                -- Checking usable
                if config.buy:GetCriteriaUsable() and item.minLevel > playerLevel then
                    break
                end

                -- Checing effect value
                if config.buy:GetCriteriaMostValue() and item.effectValue > playerStat then
                    break
                end

                baseSuitableItem = item
                suitableItems[item.id] = item
                break
            until true
        end
    end

    return suitableItems
end

function FWService:_GetNumberNeeded(items)
    local config = self:_GetConfig().buy
    local current = self:_GetTotalQuantityInBags(items)

    if (config:GetAlwaysRestock() and current < config:GetMaxRestock())
            or current < config:GetMinRestock() then
        return config:GetMaxRestock() - current, current
    end
    return 0, current
end

function FWService:_GetTotalQuantityInBags(items)
    local totalQuantity = 0
    for _, item in pairs(items) do
        for bag = 0, NUM_BAG_SLOTS do
            local numSlots = GetContainerNumSlots(bag)
            if numSlots > 0 then
                for slot = 1, numSlots do
                    local itemID = GetContainerItemID(bag, slot)
                    if item.id == itemID then
                        local containerItemInfo = ContainerItemInfo:Init(bag, slot)
                        totalQuantity = totalQuantity + containerItemInfo.itemCount
                    end
                end
            end
        end
    end

    return totalQuantity
end

function FWService:FindItemToUse()
    local suitableItems = self.suitableItems
    local suitableConjures = self:_FindMostSuitableConjures()
    local config = self:_GetConfig().actionButton

    -- Get suitable items information in bags
    local items = {}
    local conjureItems = {}
    for bag = 0, NUM_BAG_SLOTS do
        local numSlots = GetContainerNumSlots(bag)
        if numSlots > 0 then
            for slot = 1, numSlots do
                local containerItemInfo = ContainerItemInfo:Init(bag, slot)
                local itemID = GetItemID(containerItemInfo.itemLink)

                if itemID and (suitableItems[itemID] ~= nil or suitableConjures[itemID] ~= nil) then
                    local objects = items
                    local item = suitableItems[itemID]

                    if suitableConjures[itemID] ~= nil then
                        objects = conjureItems
                        item = suitableConjures[itemID]
                    end

                    if objects[itemID] == nil then
                        objects[itemID] = {
                            id = itemID,
                            bag = bag,
                            slot = slot,
                            effectValue = item.effectValue,
                            count = 0,
                        }
                    end
                    objects[itemID].count = objects[itemID].count + containerItemInfo.itemCount
                end
            end
        end
    end

    local preferConjure = config:GetPreferConjure()
    if preferConjure == PREFER_CONJURE_TYPE.ALWAYS and not table.isEmpty(conjureItems) then
        return self:_FindBestItem(conjureItems)
    end

    if preferConjure == PREFER_CONJURE_TYPE.BETTER then
         table.merge(items, conjureItems)
    end

    return self:_FindBestItem(items)
end

function FWService:_FindBestItem(items)
    local bestItem
    for _, item in pairs(items) do
        if bestItem == nil then
            bestItem = item
        else
            if item.effectValue > bestItem.effectValue
                    or (item.effectValue == bestItem.effectValue and item.count > bestItem.count) then
                bestItem = item
            end
        end
    end

    return bestItem
end

function FWService:_GetConfig()
    if self.type == FW_TYPE.FOOD then
        return Config.food
    end

    if self.type == FW_TYPE.WATER then
        return Config.water
    end
end

function FWService:_GetItems()
    if self.type == FW_TYPE.FOOD then
        return VENDOR_FOODS
    end

    if self.type == FW_TYPE.WATER then
        return VENDOR_WATERS
    end
end

function FWService:_GetPlayerStat()
    if self.type == FW_TYPE.FOOD then
        return UnitHealthMax(UNIT.PLAYER)
    end

    if self.type == FW_TYPE.WATER then
        return UnitPowerMax(UNIT.PLAYER, 0)
    end
end

function FWService:_FindMostSuitableConjures()
    local items = {}
    local playerLevel = UnitLevel(UNIT.PLAYER)
    local suitableItems = {}

    if self.type == FW_TYPE.FOOD then
        items = CONJURE_FOODS
    end

    if self.type == FW_TYPE.WATER then
        items = CONJURE_WATERS
    end


    for _, item in ipairs(items) do
        if item.minLevel <= playerLevel then
            suitableItems[item.id] = item
        end
    end

    return suitableItems
end